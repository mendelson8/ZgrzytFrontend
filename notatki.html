<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>≈öciƒÖga - NetworkStreams Chat (C#)</title>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }

      body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 20px;
          line-height: 1.6;
      }

      .container {
          max-width: 1200px;
          margin: 0 auto;
          background: white;
          border-radius: 10px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.3);
          padding: 30px;
      }

      h1 {
          color: #333;
          text-align: center;
          margin-bottom: 10px;
          font-size: 2.5em;
          border-bottom: 3px solid #667eea;
          padding-bottom: 15px;
      }

      .subtitle {
          text-align: center;
          color: #666;
          margin-bottom: 30px;
          font-style: italic;
      }

      h2 {
          color: #667eea;
          margin-top: 25px;
          margin-bottom: 15px;
          font-size: 1.8em;
          border-left: 5px solid #667eea;
          padding-left: 15px;
      }

      h3 {
          color: #764ba2;
          margin-top: 20px;
          margin-bottom: 10px;
          font-size: 1.3em;
      }

      .section {
          margin-bottom: 30px;
          padding: 20px;
          background: #f8f9fa;
          border-radius: 8px;
          border: 1px solid #e0e0e0;
      }

      .code-block {
          background: #2d2d2d;
          color: #f8f8f2;
          padding: 15px;
          border-radius: 5px;
          overflow-x: auto;
          margin: 10px 0;
          font-family: 'Courier New', Courier, monospace;
          font-size: 0.9em;
          line-height: 1.5;
      }

      .keyword {
          color: #66d9ef;
      }

      .string {
          color: #e6db74;
      }

      .comment {
          color: #75715e;
      }

      .type {
          color: #a6e22e;
      }

      ul, ol {
          margin-left: 25px;
          margin-bottom: 15px;
      }

      li {
          margin-bottom: 8px;
      }

      .important {
          background: #fff3cd;
          border-left: 4px solid #ffc107;
          padding: 15px;
          margin: 15px 0;
          border-radius: 4px;
      }

      .warning {
          background: #f8d7da;
          border-left: 4px solid #dc3545;
          padding: 15px;
          margin: 15px 0;
          border-radius: 4px;
      }

      .tip {
          background: #d1ecf1;
          border-left: 4px solid #17a2b8;
          padding: 15px;
          margin: 15px 0;
          border-radius: 4px;
      }

      .grid-2 {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 20px;
          margin: 20px 0;
      }

      .card {
          background: white;
          padding: 15px;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      }

      table {
          width: 100%;
          border-collapse: collapse;
          margin: 15px 0;
      }

      th, td {
          border: 1px solid #ddd;
          padding: 12px;
          text-align: left;
      }

      th {
          background-color: #667eea;
          color: white;
          font-weight: bold;
      }

      tr:nth-child(even) {
          background-color: #f2f2f2;
      }

      .inline-code {
          background: #e8e8e8;
          padding: 2px 6px;
          border-radius: 3px;
          font-family: 'Courier New', Courier, monospace;
          color: #d63384;
      }

      @media print {
          body {
              background: white;
              padding: 0;
          }

          .container {
              box-shadow: none;
              padding: 10px;
          }

          .code-block {
              page-break-inside: avoid;
          }
      }
  </style>
</head>
<body>
<div class="container">
  <h1>üåê ≈öciƒÖga - NetworkStreams Chat</h1>
  <div class="subtitle">Aplikacja czatu peer-to-peer z u≈ºyciem TCP w C# (.NET 9.0)</div>

  <!-- ARCHITEKTURA PROJEKTU -->
  <div class="section">
    <h2>üìÅ Architektura Projektu</h2>
    <table>
      <tr>
        <th>Projekt</th>
        <th>Opis</th>
        <th>G≈Ç√≥wne pliki</th>
      </tr>
      <tr>
        <td><strong>Chat.Common</strong></td>
        <td>Biblioteka wsp√≥lna dla serwera i klienta</td>
        <td>MessageDTO.cs, MessageReader.cs, MessageWriter.cs, MessageHandler.cs</td>
      </tr>
      <tr>
        <td><strong>ChatServer</strong></td>
        <td>Aplikacja serwerowa - po≈õredniczy miƒôdzy klientami</td>
        <td>Program.cs, ChatServer.cs</td>
      </tr>
      <tr>
        <td><strong>ChatClient</strong></td>
        <td>Aplikacja kliencka - czat u≈ºytkownika</td>
        <td>Program.cs</td>
      </tr>
    </table>
  </div>

  <!-- KLUCZOWE KONCEPCJE -->
  <div class="section">
    <h2>üîë Kluczowe Koncepcje</h2>

    <h3>1. TcpListener i TcpClient</h3>
    <div class="code-block">
      <span class="comment">// Serwer - nas≈Çuchiwanie po≈ÇƒÖcze≈Ñ</span>
      <span class="keyword">var</span> listener = <span class="keyword">new</span> <span class="type">TcpListener</span>(IPAddress.Any, port);
      listener.Start();
      <span class="keyword">var</span> client = <span class="keyword">await</span> listener.AcceptTcpClientAsync(ct);

      <span class="comment">// Klient - ≈ÇƒÖczenie siƒô z serwerem</span>
      <span class="keyword">var</span> client = <span class="keyword">new</span> <span class="type">TcpClient</span>();
      <span class="keyword">await</span> client.ConnectAsync(host, port, ct);
    </div>

    <h3>2. NetworkStream</h3>
    <p>Stream TCP s≈Çu≈ºƒÖcy do komunikacji - zar√≥wno odczytu, jak i zapisu danych.</p>
    <div class="code-block">
      <span class="type">NetworkStream</span> stream = client.GetStream();
      <span class="keyword">await</span> stream.WriteAsync(buffer, ct);
      <span class="keyword">await</span> stream.ReadAsync(buffer, offset, count, ct);
    </div>

    <h3>3. CancellationToken</h3>
    <p>Mechanizm pozwalajƒÖcy na bezpieczne anulowanie operacji asynchronicznych.</p>
    <div class="code-block">
      <span class="keyword">using var</span> cts = <span class="keyword">new</span> <span class="type">CancellationTokenSource</span>();
      <span class="keyword">var</span> ct = cts.Token;

      <span class="comment">// Anulowanie</span>
      <span class="keyword">await</span> cts.CancelAsync();

      <span class="comment">// Sprawdzanie</span>
      <span class="keyword">if</span> (ct.IsCancellationRequested) { <span class="comment">/* ... */</span> }
    </div>
  </div>

  <!-- PROTOK√ì≈Å KOMUNIKACJI -->
  <div class="section">
    <h2>üì° Protok√≥≈Ç Komunikacji</h2>

    <div class="important">
      <strong>‚ö†Ô∏è Wa≈ºne!</strong> Wiadomo≈õci sƒÖ przesy≈Çane w formacie binarnym z nag≈Ç√≥wkiem d≈Çugo≈õci.
    </div>

    <h3>Format wiadomo≈õci:</h3>
    <ol>
      <li><strong>Nag≈Ç√≥wek (4 bajty):</strong> D≈Çugo≈õƒá payloadu w formacie Big-Endian (int32)</li>
      <li><strong>Payload (zmienna d≈Çugo≈õƒá):</strong> JSON z obiektem MessageDTO w UTF-8</li>
    </ol>

    <h3>MessageDTO - struktura wiadomo≈õci:</h3>
    <div class="code-block">
      <span class="keyword">public sealed record</span> <span class="type">MessageDTO</span>
      {
      <span class="keyword">public</span> <span class="type">string</span> Content { <span class="keyword">get</span>; <span class="keyword">init</span>; } = string.Empty;
      <span class="keyword">public</span> <span class="type">string</span> Sender { <span class="keyword">get</span>; <span class="keyword">init</span>; } = string.Empty;
      <span class="keyword">public</span> <span class="type">DateTime</span> Time { <span class="keyword">get</span>; <span class="keyword">init</span>; } = DateTime.UtcNow;
      }
    </div>

    <h3>Wysy≈Çanie wiadomo≈õci (MessageWriter):</h3>
    <div class="code-block">
      <span class="keyword">public async</span> <span class="type">Task</span> WriteMessage(<span class="type">MessageDTO</span> message, <span class="type">CancellationToken</span> ct)
      {
      <span class="comment">// 1. Serializuj do JSON</span>
      <span class="type">string</span> json = JsonConvert.SerializeObject(message);
      <span class="type">byte</span>[] payload = Encoding.UTF8.GetBytes(json);

      <span class="comment">// 2. Sprawd≈∫ d≈Çugo≈õƒá (max 10KB)</span>
      <span class="keyword">if</span> (payload.Length > MaxMessageLen)
      <span class="keyword">throw new</span> <span class="type">TooLongMessageException</span>(<span class="string">$"Too long: {payload.Length}"</span>);

      <span class="comment">// 3. Utw√≥rz nag≈Ç√≥wek (4 bajty Big-Endian)</span>
      <span class="keyword">var</span> header = <span class="keyword">new byte</span>[4];
      BinaryPrimitives.WriteInt32BigEndian(header, payload.Length);

      <span class="comment">// 4. Wy≈õlij nag≈Ç√≥wek + payload</span>
      <span class="keyword">await</span> stream.WriteAsync(header, ct);
      <span class="keyword">await</span> stream.WriteAsync(payload, ct);
      <span class="keyword">await</span> stream.FlushAsync(ct);
      }
    </div>

    <h3>Odbieranie wiadomo≈õci (MessageReader):</h3>
    <div class="code-block">
      <span class="keyword">public async</span> <span class="type">Task</span>&lt;<span class="type">MessageDTO</span>?&gt; ReadMessage(<span class="type">CancellationToken</span> ct)
      {
      <span class="comment">// 1. Odczytaj nag≈Ç√≥wek (4 bajty)</span>
      <span class="keyword">var</span> headerBuffer = <span class="keyword">new byte</span>[4];
      <span class="type">int</span> bytesRead = <span class="keyword">await</span> ReadToBuffer(headerBuffer, ct);
      <span class="keyword">if</span> (bytesRead < 4) <span class="keyword">return null</span>; <span class="comment">// Roz≈ÇƒÖczenie</span>

      <span class="comment">// 2. Parsuj d≈Çugo≈õƒá payloadu</span>
      <span class="type">int</span> payloadLen = BinaryPrimitives.ReadInt32BigEndian(headerBuffer);
      <span class="keyword">if</span> (payloadLen > MaxMessageLen)
      <span class="keyword">throw new</span> <span class="type">TooLongMessageException</span>(<span class="string">$"Too long: {payloadLen}"</span>);

      <span class="comment">// 3. Odczytaj payload</span>
      <span class="keyword">var</span> payloadBuffer = <span class="keyword">new byte</span>[payloadLen];
      bytesRead = <span class="keyword">await</span> ReadToBuffer(payloadBuffer, ct);
      <span class="keyword">if</span> (bytesRead < payloadLen) <span class="keyword">return null</span>; <span class="comment">// Roz≈ÇƒÖczenie</span>

      <span class="comment">// 4. Deserializuj JSON</span>
      <span class="type">string</span> json = Encoding.UTF8.GetString(payloadBuffer);
      <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;<span class="type">MessageDTO</span>&gt;(json);
      }
    </div>

    <div class="tip">
      <strong>üí° Tip:</strong> <span class="inline-code">ReadToBuffer()</span> czyta w pƒôtli, bo <span class="inline-code">ReadAsync</span> mo≈ºe nie odczytaƒá wszystkich bajt√≥w za jednym razem!
    </div>
  </div>

  <!-- ARCHITEKTURA SERWERA -->
  <div class="section">
    <h2>üñ•Ô∏è Architektura Serwera</h2>

    <h3>G≈Ç√≥wna pƒôtla serwera:</h3>
    <div class="code-block">
      <span class="keyword">public async</span> <span class="type">Task</span> Run(<span class="type">CancellationToken</span> ct)
      {
      <span class="keyword">while</span> (!ct.IsCancellationRequested)
      {
      <span class="keyword">using var</span> listener = <span class="keyword">new</span> <span class="type">TcpListener</span>(address, port);
      listener.Start();

      <span class="comment">// Czekaj na dw√≥ch klient√≥w</span>
      <span class="keyword">using var</span> client1 = <span class="keyword">await</span> listener.AcceptTcpClientAsync(ct);
      <span class="keyword">using var</span> client2 = <span class="keyword">await</span> listener.AcceptTcpClientAsync(ct);

      <span class="comment">// Obs≈Çuguj parƒô klient√≥w</span>
      <span class="keyword">await</span> HandleClientsAsync(client1, client2, ct);
      }
      }
    </div>

    <h3>Obs≈Çuga pary klient√≥w:</h3>
    <ol>
      <li>Pobierz <span class="inline-code">NetworkStream</span> dla obu klient√≥w</li>
      <li>Utw√≥rz <span class="inline-code">MessageReader</span> i <span class="inline-code">MessageWriter</span> dla ka≈ºdego klienta</li>
      <li>Uruchom dwa zadania asynchroniczne do przekazywania wiadomo≈õci:
        <ul>
          <li>Klient1 ‚Üí Klient2</li>
          <li>Klient2 ‚Üí Klient1</li>
        </ul>
      </li>
      <li>Czekaj na zako≈Ñczenie kt√≥regokolwiek zadania (<span class="inline-code">Task.WhenAny</span>)</li>
      <li>Wy≈õlij powiadomienie do pozosta≈Çego klienta</li>
    </ol>

    <div class="code-block">
      <span class="keyword">static async</span> <span class="type">Task</span> HandleClientsAsync(<span class="type">TcpClient</span> client1, <span class="type">TcpClient</span> client2, <span class="type">CancellationToken</span> ct)
      {
      <span class="keyword">await using var</span> stream1 = client1.GetStream();
      <span class="keyword">await using var</span> stream2 = client2.GetStream();

      <span class="keyword">using var</span> messageForwardCts = <span class="keyword">new</span> <span class="type">CancellationTokenSource</span>();

      <span class="keyword">using var</span> readerFromClient1 = <span class="keyword">new</span> <span class="type">MessageReader</span>(stream1);
      <span class="keyword">using var</span> readerFromClient2 = <span class="keyword">new</span> <span class="type">MessageReader</span>(stream2);
      <span class="keyword">using var</span> writerToClient1 = <span class="keyword">new</span> <span class="type">MessageWriter</span>(stream1);
      <span class="keyword">using var</span> writerToClient2 = <span class="keyword">new</span> <span class="type">MessageWriter</span>(stream2);

      <span class="comment">// Uruchom przekazywanie wiadomo≈õci</span>
      <span class="keyword">var</span> t1 = ForwardMessagesAsync(readerFromClient1, writerToClient2, messageForwardCts.Token);
      <span class="keyword">var</span> t2 = ForwardMessagesAsync(readerFromClient2, writerToClient1, messageForwardCts.Token);
      <span class="keyword">var</span> cancellationTask = Task.Delay(-1, ct);

      <span class="comment">// Czekaj na pierwsze zako≈Ñczenie</span>
      <span class="keyword">var</span> finishedTask = <span class="keyword">await</span> Task.WhenAny(t1, t2, cancellationTask);

      <span class="comment">// Wy≈õlij powiadomienia</span>
      <span class="keyword">if</span> (finishedTask == cancellationTask)
      {
      <span class="keyword">await</span> SendCancellationNotification(writerToClient1);
      <span class="keyword">await</span> SendCancellationNotification(writerToClient2);
      }
      <span class="keyword">else</span>
      {
      <span class="keyword">var</span> remainingClientWriter = finishedTask == t1 ? writerToClient2 : writerToClient1;
      <span class="keyword">await</span> SendPeerDisconnectedNotification(remainingClientWriter, ct);
      }

      <span class="keyword">await</span> messageForwardCts.CancelAsync();
      <span class="keyword">await</span> Task.WhenAll(t1, t2);
      }
    </div>

    <h3>Przekazywanie wiadomo≈õci:</h3>
    <div class="code-block">
      <span class="keyword">static async</span> <span class="type">Task</span> ForwardMessagesAsync(<span class="type">MessageReader</span> reader, <span class="type">MessageWriter</span> writer, <span class="type">CancellationToken</span> ct)
      {
      <span class="keyword">try</span>
      {
      <span class="keyword">while</span> (!ct.IsCancellationRequested)
      {
      <span class="keyword">var</span> msg = <span class="keyword">await</span> reader.ReadMessage(ct);
      <span class="keyword">if</span> (msg == <span class="keyword">null</span>) <span class="comment">// Klient siƒô roz≈ÇƒÖczy≈Ç</span>
      <span class="keyword">break</span>;

      Console.WriteLine(<span class="string">$"{msg.Sender}: {msg.Content}"</span>);
      <span class="keyword">await</span> writer.WriteMessage(msg, ct);
      }
      }
      <span class="keyword">catch</span> (<span class="type">OperationCanceledException</span>) { }
      <span class="keyword">catch</span> (<span class="type">IOException</span>) { }
      }
    </div>
  </div>

  <!-- ARCHITEKTURA KLIENTA -->
  <div class="section">
    <h2>üíª Architektura Klienta</h2>

    <h3>G≈Ç√≥wny przep≈Çyw:</h3>
    <ol>
      <li>Po≈ÇƒÖcz siƒô z serwerem (<span class="inline-code">TcpClient.ConnectAsync</span>)</li>
      <li>Pobierz <span class="inline-code">NetworkStream</span></li>
      <li>Uruchom asynchroniczny wƒÖtek odbiorczy (<span class="inline-code">MessageReceiver</span>)</li>
      <li>W g≈Ç√≥wnej pƒôtli czytaj od u≈ºytkownika i wysy≈Çaj wiadomo≈õci</li>
      <li>Po wpisaniu "exit" - zako≈Ñcz</li>
    </ol>

    <h3>≈ÅƒÖczenie z timeoutem:</h3>
    <div class="code-block">
      <span class="keyword">static async</span> <span class="type">Task</span>&lt;<span class="type">TcpClient</span>?&gt; Connect(<span class="type">string</span> host, <span class="type">int</span> port, <span class="type">IProgress</span>&lt;<span class="type">string</span>&gt; progress)
      {
      <span class="keyword">using var</span> cts = <span class="keyword">new</span> <span class="type">CancellationTokenSource</span>(3000); <span class="comment">// 3s timeout</span>
      <span class="keyword">var</span> client = <span class="keyword">new</span> <span class="type">TcpClient</span>();

      <span class="keyword">try</span> {
      <span class="keyword">await</span> client.ConnectAsync(host, port, cts.Token);
      progress.Report(<span class="string">"Connected to server"</span>);
      <span class="keyword">return</span> client;
      }
      <span class="keyword">catch</span> (<span class="type">OperationCanceledException</span>)
      {
      progress.Report(<span class="string">"[TIMEOUT] Failed to connect"</span>);
      <span class="keyword">return null</span>;
      }
      }
    </div>

    <h3>Odbieranie wiadomo≈õci (osobny wƒÖtek):</h3>
    <div class="code-block">
      <span class="keyword">static async</span> <span class="type">Task</span> MessageReceiver(<span class="type">NetworkStream</span> stream, <span class="type">IProgress</span>&lt;<span class="type">string</span>&gt; progress, <span class="type">CancellationTokenSource</span> cts)
      {
      <span class="keyword">var</span> ct = cts.Token;
      <span class="keyword">using var</span> reader = <span class="keyword">new</span> <span class="type">MessageReader</span>(stream);

      <span class="keyword">try</span> {
      <span class="keyword">while</span> (!ct.IsCancellationRequested)
      {
      <span class="type">MessageDTO</span>? msg = <span class="keyword">await</span> reader.ReadMessage(ct);
      <span class="keyword">if</span> (msg == <span class="keyword">null</span>) {
      progress.Report(<span class="string">"[System] Your peer disconnected."</span>);
      cts.Cancel(); <span class="comment">// Anuluj wszystko</span>
      <span class="keyword">break</span>;
      }

      Console.WriteLine(<span class="string">$"[{msg.Time:u}] {msg.Sender}: {msg.Content}"</span>);
      }
      }
      <span class="keyword">catch</span> (<span class="type">OperationCanceledException</span>) { }
      <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
      progress.Report(<span class="string">$"[Error]: {e.Message}"</span>);
      }
      }
    </div>

    <h3>Wysy≈Çanie wiadomo≈õci (g≈Ç√≥wna pƒôtla):</h3>
    <div class="code-block">
      <span class="keyword">using var</span> sender = <span class="keyword">new</span> <span class="type">MessageWriter</span>(stream);

      <span class="keyword">while</span> (<span class="keyword">true</span>)
      {
      <span class="type">string</span>? msg = Console.ReadLine();
      <span class="keyword">if</span> (msg == <span class="keyword">null</span> || msg.Equals(<span class="string">"exit"</span>, StringComparison.OrdinalIgnoreCase))
      <span class="keyword">break</span>;

      <span class="keyword">var</span> dto = <span class="keyword">new</span> <span class="type">MessageDTO</span>
      {
      Content = msg,
      Sender = name,
      Time = DateTime.UtcNow
      };

      <span class="keyword">try</span> {
      <span class="keyword">await</span> sender.WriteMessage(dto, cts.Token);
      }
      <span class="keyword">catch</span> (<span class="type">TooLongMessageException</span>) {
      progress.Report(<span class="string">"[ERROR] Message was too long."</span>);
      }
      }
    </div>
  </div>

  <!-- OBS≈ÅUGA B≈ÅƒòD√ìW -->
  <div class="section">
    <h2>‚ö†Ô∏è Obs≈Çuga B≈Çƒôd√≥w i WyjƒÖtk√≥w</h2>

    <table>
      <tr>
        <th>WyjƒÖtek</th>
        <th>Kiedy wystƒôpuje</th>
        <th>Jak obs≈Çu≈ºyƒá</th>
      </tr>
      <tr>
        <td><strong>OperationCanceledException</strong></td>
        <td>Operacja zosta≈Ça anulowana przez CancellationToken</td>
        <td>Normalny shutdown - mo≈ºna zignorowaƒá lub logowaƒá</td>
      </tr>
      <tr>
        <td><strong>IOException</strong></td>
        <td>B≈ÇƒÖd podczas komunikacji sieciowej</td>
        <td>Oznacza roz≈ÇƒÖczenie - zako≈Ñcz obs≈Çugƒô klienta</td>
      </tr>
      <tr>
        <td><strong>TooLongMessageException</strong></td>
        <td>Wiadomo≈õƒá przekracza 10KB</td>
        <td>Poinformuj u≈ºytkownika, nie wysy≈Çaj</td>
      </tr>
      <tr>
        <td><strong>InvalidMessageException</strong></td>
        <td>B≈ÇƒÖd deserializacji JSON</td>
        <td>Zaloguj b≈ÇƒÖd, mo≈ºesz kontynuowaƒá lub zamknƒÖƒá po≈ÇƒÖczenie</td>
      </tr>
    </table>

    <div class="warning">
      <strong>üö® Wa≈ºne:</strong> Zawsze u≈ºywaj <span class="inline-code">using</span> dla zasob√≥w sieciowych (<span class="inline-code">TcpClient</span>, <span class="inline-code">NetworkStream</span>, <span class="inline-code">MessageReader/Writer</span>) aby zapewniƒá ich poprawne zwolnienie!
    </div>
  </div>

  <!-- WZORCE ASYNC/AWAIT -->
  <div class="section">
    <h2>‚ö° Wzorce Async/Await</h2>

    <h3>1. Task.WhenAny - czekanie na pierwsze zako≈Ñczenie:</h3>
    <div class="code-block">
      <span class="keyword">var</span> t1 = TaskA();
      <span class="keyword">var</span> t2 = TaskB();
      <span class="keyword">var</span> finishedTask = <span class="keyword">await</span> Task.WhenAny(t1, t2);

      <span class="keyword">if</span> (finishedTask == t1)
      Console.WriteLine(<span class="string">"Task A finished first"</span>);
    </div>

    <h3>2. Task.WhenAll - czekanie na wszystkie:</h3>
    <div class="code-block">
      <span class="keyword">var</span> t1 = TaskA();
      <span class="keyword">var</span> t2 = TaskB();
      <span class="keyword">await</span> Task.WhenAll(t1, t2); <span class="comment">// Czeka a≈º obie siƒô zako≈ÑczƒÖ</span>
    </div>

    <h3>3. Task.Delay z CancellationToken:</h3>
    <div class="code-block">
      <span class="comment">// Niesko≈Ñczone op√≥≈∫nienie (do momentu anulowania)</span>
      <span class="keyword">var</span> cancellationTask = Task.Delay(-1, ct);

      <span class="comment">// Timeout</span>
      <span class="keyword">using var</span> cts = <span class="keyword">new</span> <span class="type">CancellationTokenSource</span>(3000); <span class="comment">// 3 sekundy</span>
    </div>

    <h3>4. IProgress&lt;T&gt; - raportowanie postƒôpu:</h3>
    <div class="code-block">
      <span class="type">IProgress</span>&lt;<span class="type">string</span>&gt; progress = <span class="keyword">new</span> <span class="type">Progress</span>&lt;<span class="type">string</span>&gt;(Console.WriteLine);
      progress.Report(<span class="string">"Connected to server"</span>);
    </div>

    <div class="tip">
      <strong>üí° Tip:</strong> U≈ºywaj <span class="inline-code">await using</span> dla obiekt√≥w implementujƒÖcych <span class="inline-code">IAsyncDisposable</span> (np. streams).
    </div>
  </div>

  <!-- URUCHAMIANIE -->
  <div class="section">
    <h2>üöÄ Uruchamianie Aplikacji</h2>

    <h3>1. Kompilacja projektu:</h3>
    <div class="code-block">
      <span class="comment"># W g≈Ç√≥wnym katalogu projektu</span>
      dotnet build
    </div>

    <h3>2. Uruchomienie serwera:</h3>
    <div class="code-block">
      <span class="comment"># Terminal 1</span>
      cd ChatServer
      dotnet run
      <span class="comment"># Nas≈Çuchuje na porcie 5000</span>
    </div>

    <h3>3. Uruchomienie klient√≥w:</h3>
    <div class="code-block">
      <span class="comment"># Terminal 2 - Klient 1</span>
      cd ChatClient
      dotnet run
      <span class="comment"># lub: dotnet run localhost 5000</span>

      <span class="comment"># Terminal 3 - Klient 2</span>
      cd ChatClient
      dotnet run
    </div>

    <h3>4. Zatrzymanie serwera:</h3>
    <p>Naci≈õnij <kbd>Ctrl+C</kbd> w terminalu z serwerem - graceful shutdown dziƒôki <span class="inline-code">Console.CancelKeyPress</span>.</p>
  </div>

  <!-- WSKAZ√ìWKI NA EGZAMIN -->
  <div class="section">
    <h2>üìù Wskaz√≥wki na Egzamin/Lab</h2>

    <div class="grid-2">
      <div class="card">
        <h3>‚úÖ Zapamiƒôtaj:</h3>
        <ul>
          <li>Protok√≥≈Ç: 4-byte header (Big-Endian) + JSON payload</li>
          <li>Max rozmiar wiadomo≈õci: 10KB (10240 bajt√≥w)</li>
          <li>Port domy≈õlny: 5000</li>
          <li>Encoding: UTF-8</li>
          <li>Serializacja: Newtonsoft.Json</li>
          <li><span class="inline-code">ReadAsync</span> mo≈ºe nie odczytaƒá wszystkich bajt√≥w!</li>
        </ul>
      </div>

      <div class="card">
        <h3>üéØ Czƒôste b≈Çƒôdy:</h3>
        <ul>
          <li>Brak obs≈Çugi czƒô≈õciowego odczytu</li>
          <li>Zapomnienie o <span class="inline-code">FlushAsync()</span></li>
          <li>Niew≈Ça≈õciwa kolejno≈õƒá bajt√≥w (Little vs Big-Endian)</li>
          <li>Niezwolnione zasoby (brak <span class="inline-code">using</span>)</li>
          <li>Brak obs≈Çugi <span class="inline-code">null</span> przy roz≈ÇƒÖczeniu</li>
        </ul>
      </div>
    </div>

    <div class="important">
      <strong>üìå Kluczowe punkty do zrozumienia:</strong>
      <ol>
        <li><strong>Dlaczego Big-Endian?</strong> Standard sieciowy (network byte order)</li>
        <li><strong>Dlaczego header z d≈Çugo≈õciƒÖ?</strong> TCP jest strumieniem - nie wiesz gdzie ko≈Ñczy siƒô wiadomo≈õƒá</li>
        <li><strong>Dlaczego pƒôtla w ReadToBuffer?</strong> TCP mo≈ºe dostarczaƒá dane w kawa≈Çkach</li>
        <li><strong>Dlaczego CancellationToken?</strong> Graceful shutdown i cooperative cancellation</li>
        <li><strong>Dlaczego Task.WhenAny?</strong> Reagowanie na pierwsze zdarzenie (roz≈ÇƒÖczenie lub shutdown)</li>
      </ol>
    </div>
  </div>

  <!-- ROZSZERZENIA -->
  <div class="section">
    <h2>üîß Mo≈ºliwe Rozszerzenia</h2>

    <ul>
      <li>‚ú® <strong>Chat grupowy:</strong> Wiƒôcej ni≈º 2 klient√≥w</li>
      <li>üîê <strong>Szyfrowanie:</strong> SSL/TLS z <span class="inline-code">SslStream</span></li>
      <li>üë§ <strong>Autoryzacja:</strong> Login/has≈Ço przed czatem</li>
      <li>üìÅ <strong>Transfer plik√≥w:</strong> Rozszerzenie protoko≈Çu o typ wiadomo≈õci</li>
      <li>üíæ <strong>Historia:</strong> Zapisywanie wiadomo≈õci do bazy danych</li>
      <li>üé® <strong>GUI:</strong> WPF/WinForms/Avalonia zamiast konsoli</li>
      <li>üåç <strong>Web:</strong> SignalR dla klient√≥w webowych</li>
    </ul>
  </div>

  <!-- PRZYDATNE KLASY -->
  <div class="section">
    <h2>üìö Przydatne klasy .NET</h2>

    <table>
      <tr>
        <th>Klasa</th>
        <th>Namespace</th>
        <th>Do czego s≈Çu≈ºy</th>
      </tr>
      <tr>
        <td><strong>TcpListener</strong></td>
        <td>System.Net.Sockets</td>
        <td>Nas≈Çuchiwanie po≈ÇƒÖcze≈Ñ TCP</td>
      </tr>
      <tr>
        <td><strong>TcpClient</strong></td>
        <td>System.Net.Sockets</td>
        <td>Klient TCP</td>
      </tr>
      <tr>
        <td><strong>NetworkStream</strong></td>
        <td>System.Net.Sockets</td>
        <td>Stream do komunikacji TCP</td>
      </tr>
      <tr>
        <td><strong>BinaryPrimitives</strong></td>
        <td>System.Buffers.Binary</td>
        <td>Operacje na bajtach (endianness)</td>
      </tr>
      <tr>
        <td><strong>Encoding</strong></td>
        <td>System.Text</td>
        <td>Konwersja string ‚Üî byte[]</td>
      </tr>
      <tr>
        <td><strong>JsonConvert</strong></td>
        <td>Newtonsoft.Json</td>
        <td>Serializacja/deserializacja JSON</td>
      </tr>
      <tr>
        <td><strong>CancellationTokenSource</strong></td>
        <td>System.Threading</td>
        <td>Anulowanie operacji async</td>
      </tr>
    </table>
  </div>

  <!-- FOOTER -->
  <div style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 2px solid #667eea; color: #666;">
    <p><strong>NetworkStreams Chat - ≈öciƒÖga</strong></p>
    <p>C# | .NET 9.0 | TCP Networking | Async/Await</p>
    <p style="font-size: 0.9em; margin-top: 10px;">Powodzenia na labach! üöÄ</p>
  </div>
</div>
</body>
</html>
