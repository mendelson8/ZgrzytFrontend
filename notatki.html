<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Programowanie Sieciowe w C# - Notatki na Laboratoria</title>
  <style>
      :root {
          --primary-color: #0056b3;
          --bg-color: #f4f4f9;
          --text-color: #333;
          --code-bg: #2d2d2d;
          --code-text: #f8f8f2;
          --accent-color: #d63384;
          --warning-bg: #fff3cd;
          --warning-text: #856404;
      }

      body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          line-height: 1.6;
          color: var(--text-color);
          background-color: var(--bg-color);
          margin: 0;
          padding: 20px;
      }

      .container {
          max-width: 900px;
          margin: 0 auto;
          background: white;
          padding: 40px;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      }

      h1 {
          color: var(--primary-color);
          border-bottom: 2px solid var(--primary-color);
          padding-bottom: 10px;
      }

      h2 {
          color: var(--primary-color);
          margin-top: 40px;
      }

      h3 {
          color: #444;
          margin-top: 25px;
      }

      p {
          margin-bottom: 15px;
      }

      code {
          font-family: 'Consolas', 'Monaco', monospace;
          background-color: #e9ecef;
          padding: 2px 4px;
          border-radius: 4px;
          color: var(--accent-color);
      }

      pre {
          background-color: var(--code-bg);
          color: var(--code-text);
          padding: 15px;
          border-radius: 8px;
          overflow-x: auto;
          border-left: 5px solid var(--accent-color);
      }

      .note {
          background-color: #e7f5ff;
          border-left: 5px solid #0056b3;
          padding: 15px;
          margin: 20px 0;
      }

      .warning {
          background-color: var(--warning-bg);
          border-left: 5px solid #ffc107;
          padding: 15px;
          color: var(--warning-text);
          margin: 20px 0;
      }

      .diagram {
          font-family: 'Courier New', monospace;
          white-space: pre;
          background: #fff;
          border: 1px dashed #aaa;
          padding: 10px;
          margin: 20px 0;
          text-align: center;
          font-weight: bold;
      }

      ul {
          padding-left: 20px;
      }

      li {
          margin-bottom: 8px;
      }
  </style>
</head>
<body>

<div class="container">

  <h1>Programowanie Sieciowe w C# (TCP/IP)</h1>
  <p>Kompendium wiedzy oparte na analizie kodu klienta/serwera czatu. Kluczowe zagadnienia: strumienie, framing wiadomości, asynchroniczność.</p>

  <h2>1. Protokół Binarny i "Framing" Wiadomości</h2>

  <div class="note">
    <strong>Dlaczego to robimy?</strong> TCP to strumień (stream), a nie paczki. Jeśli wyślesz "ABC" i "DEF", odbiorca może dostać "ABCDEF", "A", "BCDEF" lub dowolną inną kombinację.
    <br>Aby wiedzieć, gdzie kończy się jedna wiadomość, a zaczyna druga, stosujemy <strong>Length-Prefixing</strong> (nagłówek długości).
  </div>

  <div class="diagram">
    [ NAGŁÓWEK (4 bajty) ] + [ PAYLOAD (N bajtów) ]<br>
    | 00 | 00 | 00 | 15 | -> | { "User": "Jan", ... } |
  </div>

  <h3>Wysyłanie (MessageWriter)</h3>
  <ol>
    <li>Zserializuj obiekt do JSON (string).</li>
    <li>Zamień string na bajty (UTF-8).</li>
    <li>Oblicz długość tablicy bajtów.</li>
    <li>Utwórz nagłówek (4 bajty int) w formacie <strong>BigEndian</strong>.</li>
    <li>Wyślij nagłówek, potem dane, potem zrób <code>Flush()</code>.</li>
  </ol>

  <pre><code>// Kluczowy fragment zapisu
var header = new byte[4];
BinaryPrimitives.WriteInt32BigEndian(header, payload.Length);

await stream.WriteAsync(header, ct);  // Krok 1: Długość
await stream.WriteAsync(payload, ct); // Krok 2: Treść
await stream.FlushAsync(ct);          // Krok 3: Wypchnięcie</code></pre>

  <h3>Odbieranie (MessageReader)</h3>
  <p>Odbieranie jest trudniejsze, bo dane mogą przychodzić w kawałkach. Musimy użyć pętli.</p>

  <div class="warning">
    <strong>Pamiętaj na laboratoria!</strong> Nigdy nie zakładaj, że <code>stream.ReadAsync()</code> zwróci tyle bajtów, o ile prosiłeś. Zawsze sprawdzaj wartość zwracaną (liczbę faktycznie odczytanych bajtów).
  </div>

  <pre><code>// Poprawna pętla czytająca do pełnego bufora
private async Task&lt;int&gt; ReadToBuffer(byte[] buffer, CancellationToken ct)
{
    int bytesRead = 0;

    // Czytaj dopóki nie zapełnisz bufora
    while (bytesRead < buffer.Length)
    {
        int chunk = await stream.ReadAsync(buffer, bytesRead,
                                           buffer.Length - bytesRead, ct);
        if (chunk == 0) return bytesRead; // Zerwanie połączenia
        bytesRead += chunk;
    }
    return bytesRead;
}</code></pre>

  <hr>

  <h2>2. Big Endian vs Little Endian</h2>
  <p>W sieciach standardem jest <strong>Big Endian</strong> (Network Byte Order). Systemy Windows (Intel/AMD) używają zazwyczaj <strong>Little Endian</strong>.</p>
  <ul>
    <li><code>BinaryPrimitives.WriteInt32BigEndian</code> - bezpieczny sposób na konwersję niezależnie od procesora.</li>
    <li>Jeśli wyślesz długość w złej kolejności bajtów, odbiorca odczyta np. zamiast liczby <code>21</code> liczbę <code>352321536</code> i spróbuje zaalokować gigantyczną ilość pamięci -> <strong>Out Of Memory Exception</strong>.</li>
  </ul>

  <hr>

  <h2>3. Nawiązywanie połączenia z Timeoutem</h2>
  <p>Domyślny <code>ConnectAsync</code> w starszych wersjach .NET lub niektórych przeciążeniach nie obsługuje <code>CancellationToken</code>. Aby nie "wisieć" w nieskończoność, stosujemy trik.</p>

  <h3>Wzorzec implementacji:</h3>
  <pre><code>using var cts = new CancellationTokenSource(5000); // 5 sekund timeout
try {
    // Przekazujemy token z naszego źródła czasu
    await client.ConnectAsync(host, port, cts.Token);
}
catch (OperationCanceledException) {
    // Złapane! Minęło 5 sekund.
    Console.WriteLine("Timeout!");
}</code></pre>

  <hr>

  <h2>4. Architektura Serwera (TCP Listener)</h2>
  <p>Przeanalizowany kod serwera implementuje model <strong>sekwencyjnego parowania</strong>.</p>

  <div class="diagram">
    Start -> Czekaj na Klienta 1 -> Czekaj na Klienta 2 -> <br>
    [Połącz ich i blokuj pętlę] -> Koniec rozmowy -> Wróć do startu
  </div>

  <ul>
    <li><code>TcpListener</code> - nasłuchuje na porcie ("otwiera drzwi").</li>
    <li><code>AcceptTcpClientAsync</code> - czeka i zwraca obiekt <code>TcpClient</code> dla konkretnego połączenia.</li>
    <li><code>using</code> - bardzo ważne przy <code>TcpClient</code>. Połączenia to niezarządzane zasoby (file handles). Muszą być zwalniane (Dispose).</li>
  </ul>

  <hr>

  <h2>5. Protokół Tekstowy (StreamReader/Writer)</h2>
  <p>Alternatywa dla protokołu binarnego. Łatwiejsza do debugowania (można użyć Telneta), ale wolniejsza i mniej elastyczna przy przesyłaniu plików/obrazków.</p>

  <ul>
    <li><strong>Separator:</strong> Znak nowej linii (<code>\n</code>).</li>
    <li><strong>Narzędzia:</strong> <code>StreamReader.ReadLineAsync()</code> oraz <code>StreamWriter.WriteLineAsync()</code>.</li>
  </ul>

  <div class="warning">
    <strong>Pułapka Flush:</strong> <code>StreamWriter</code> buforuje dane. Jeśli napiszesz <code>WriteLineAsync()</code> i nie zrobisz <code>FlushAsync()</code>, wiadomość może nie wyjść z Twojego komputera, dopóki bufor się nie przepełni (np. 4KB). Zawsze rób <strong>Flush</strong>!
  </div>

  <hr>

  <h2>6. Ściąga na Laborki - Najczęstsze Błędy</h2>

  <table border="1" cellpadding="10" cellspacing="0" style="width:100%; border-collapse: collapse; margin-top: 10px;">
    <tr style="background-color: #f2f2f2;">
      <th>Objaw</th>
      <th>Prawdopodobna Przyczyna</th>
      <th>Rozwiązanie</th>
    </tr>
    <tr>
      <td>Wiadomość nie dociera, program "wisi"</td>
      <td>Brak <code>FlushAsync()</code> po zapisie.</td>
      <td>Dodaj <code>writer.FlushAsync()</code> lub <code>stream.FlushAsync()</code>.</td>
    </tr>
    <tr>
      <td>Odbieram "śmieci" lub błąd pamięci</td>
      <td>Błędna kolejność bajtów (Endianness).</td>
      <td>Używaj <code>BinaryPrimitives...BigEndian</code> po obu stronach.</td>
    </tr>
    <tr>
      <td>Serwer działa tylko dla jednej osoby</td>
      <td>Blokowanie w pętli głównej bez <code>Task.Run</code>.</td>
      <td>Jeśli serwer ma obsługiwać wielu na raz, obsługa klienta musi być w osobnym Tasku.</td>
    </tr>
    <tr>
      <td>JSON deserializuje się jako null</td>
      <td>Błędy kodowania tekstu.</td>
      <td>Upewnij się, że używasz <code>Encoding.UTF8</code> po obu stronach.</td>
    </tr>
    <tr>
      <td>Wyjątek <code>DisposedObjectException</code></td>
      <td>Próba zapisu do strumienia po wyjściu z bloku <code>using</code>.</td>
      <td>Sprawdź zakresy zmiennych i kiedy zamykasz połączenie.</td>
    </tr>
  </table>

</div>

</body>
</html>